import { mkdir, writeFile } from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import dotenv from 'dotenv';
import { Client } from 'pg';

dotenv.config();

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const {
  LEDGER_DB_HOST = '127.0.0.1',
  LEDGER_DB_PORT = '5433',
  LEDGER_DB_NAME = 'postgres',
  LEDGER_DB_USER = 'postgres',
  LEDGER_DB_PASSWORD,
} = process.env;

if (!LEDGER_DB_PASSWORD) {
  console.error('Missing required env var LEDGER_DB_PASSWORD');
  process.exit(1);
}

const QUERY = `
SELECT
  code,
  name,
  type,
  is_control,
  subledger,
  posting_allowed
FROM public.accounts
WHERE status = 'active' OR status IS NULL
ORDER BY code;
`;

const defaults = {
  DEFAULT_REVENUE_SERVICE: 4000,
  DEFAULT_REVENUE_PRODUCT: 4010,
  DEFAULT_VAT_OUTPUT: 2100,
  DEFAULT_VAT_INPUT: 1200,
};

async function main() {
  const client = new Client({
    host: LEDGER_DB_HOST,
    port: Number(LEDGER_DB_PORT),
    database: LEDGER_DB_NAME,
    user: LEDGER_DB_USER,
    password: LEDGER_DB_PASSWORD,
    ssl: false,
  });

  try {
    await client.connect();

    const { rows } = await client.query(QUERY);
    const accounts = rows.map((row) => ({
      code: Number(row.code),
      name: row.name,
      type: String(row.type || '').toUpperCase(),
      isControl: row.is_control === true,
      subledger: row.subledger ?? null,
      postingAllowed: row.posting_allowed !== false,
    }));

    const timestamp = new Date().toISOString();
    const sourceLabel = `${LEDGER_DB_HOST}:${LEDGER_DB_PORT}/${LEDGER_DB_NAME}`;

    const fileBody = buildOutput(accounts, timestamp, sourceLabel);
    const outputPath = path.resolve(__dirname, '../src/data/chartOfAccounts.js');

    await mkdir(path.dirname(outputPath), { recursive: true });
    await writeFile(outputPath, fileBody, 'utf8');

    console.log(`Wrote ${accounts.length} accounts to ${path.relative(process.cwd(), outputPath)}`);
  } catch (err) {
    console.error('Failed to sync chart of accounts:', err.message);
    process.exit(1);
  } finally {
    await client.end().catch(() => {});
  }
}

function buildOutput(accounts, timestamp, sourceLabel) {
  const entries = accounts
    .map((a) => {
      const subledger = a.subledger ? JSON.stringify(a.subledger) : 'null';
      return `  { code: ${a.code}, name: ${JSON.stringify(a.name)}, type: ${JSON.stringify(a.type)}, isControl: ${a.isControl}, subledger: ${subledger}, postingAllowed: ${a.postingAllowed} },`;
    })
    .join('\n');

  return `// Auto-generated by scripts/syncChartOfAccounts.mjs
// Last synced: ${timestamp}
// Source: ${sourceLabel}

export const chartOfAccounts = [
${entries}
];

export const accountByCode = new Map(chartOfAccounts.map((a) => [a.code, a]));

export const revenueAccounts = chartOfAccounts.filter((a) => a.type === 'INCOME' && a.postingAllowed);
export const expenseAccounts = chartOfAccounts.filter((a) => a.type === 'EXPENSE' && a.postingAllowed);
export const vatAccounts = chartOfAccounts.filter((a) => a.subledger === 'VAT' && a.postingAllowed);

export const DEFAULT_REVENUE_SERVICE = ${defaults.DEFAULT_REVENUE_SERVICE};
export const DEFAULT_REVENUE_PRODUCT = ${defaults.DEFAULT_REVENUE_PRODUCT};
export const DEFAULT_VAT_OUTPUT = ${defaults.DEFAULT_VAT_OUTPUT};
export const DEFAULT_VAT_INPUT = ${defaults.DEFAULT_VAT_INPUT};
`;
}

main();
